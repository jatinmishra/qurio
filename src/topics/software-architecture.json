
{
  "id": "software-architecture",
  "title": "Software Architecture",
  "description": "Design patterns and architectural principles",
  "icon": "Database",
  "levels": {
    "1": {
      "questions": [
        {
          "id": "arch-1-1",
          "question": "What is the main principle of the Single Responsibility Principle (SRP)?",
          "options": [
            "A class should have only one method",
            "A class should have only one reason to change",
            "A class should inherit from only one parent",
            "A class should implement only one interface"
          ],
          "correctAnswer": 1,
          "explanation": "The Single Responsibility Principle states that a class should have only one reason to change, meaning it should have only one job or responsibility. This makes the code more maintainable and reduces coupling."
        },
        {
          "id": "arch-1-2",
          "question": "Which design pattern is used to ensure a class has only one instance?",
          "options": [
            "Factory Pattern",
            "Observer Pattern",
            "Singleton Pattern",
            "Strategy Pattern"
          ],
          "correctAnswer": 2,
          "explanation": "The Singleton pattern ensures that a class has only one instance and provides a global point of access to that instance. It's commonly used for logging, configuration, and database connections."
        },
        {
          "id": "arch-1-3",
          "question": "What is the Open/Closed Principle?",
          "options": [
            "Classes should be open for modification, closed for extension",
            "Classes should be open for extension, closed for modification",
            "Classes should always be open",
            "Classes should always be closed"
          ],
          "correctAnswer": 1,
          "explanation": "The Open/Closed Principle states that software entities should be open for extension but closed for modification. You should be able to extend behavior without modifying existing code."
        },
        {
          "id": "arch-1-4",
          "question": "What is the Factory Pattern used for?",
          "options": [
            "Creating objects without specifying their exact class",
            "Managing object lifecycle",
            "Implementing inheritance",
            "Handling exceptions"
          ],
          "correctAnswer": 0,
          "explanation": "The Factory Pattern creates objects without specifying the exact class of object that will be created, providing a way to encapsulate object creation logic."
        },
        {
          "id": "arch-1-5",
          "question": "What is the Dependency Inversion Principle?",
          "options": [
            "High-level modules should depend on low-level modules",
            "High-level modules should not depend on low-level modules; both should depend on abstractions",
            "Dependencies should be inverted in the code",
            "Classes should not have dependencies"
          ],
          "correctAnswer": 1,
          "explanation": "The Dependency Inversion Principle states that high-level modules should not depend on low-level modules. Both should depend on abstractions, and abstractions should not depend on details."
        },
        {
          "id": "arch-1-6",
          "question": "What is the Observer Pattern?",
          "options": [
            "A pattern for watching user behavior",
            "A pattern where an object maintains a list of dependents and notifies them of changes",
            "A pattern for observing system performance",
            "A pattern for monitoring network traffic"
          ],
          "correctAnswer": 1,
          "explanation": "The Observer Pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically."
        },
        {
          "id": "arch-1-7",
          "question": "What is the Interface Segregation Principle?",
          "options": [
            "Interfaces should be as large as possible",
            "Clients should not be forced to depend on interfaces they don't use",
            "Interfaces should be segregated by access level",
            "All classes should implement the same interface"
          ],
          "correctAnswer": 1,
          "explanation": "The Interface Segregation Principle states that clients should not be forced to depend on interfaces they don't use. It's better to have many small, specific interfaces than one large general-purpose interface."
        },
        {
          "id": "arch-1-8",
          "question": "What is coupling in software design?",
          "options": [
            "How classes are connected or paired",
            "The degree of direct knowledge one element has of another",
            "The speed of communication between modules",
            "The amount of memory used by objects"
          ],
          "correctAnswer": 1,
          "explanation": "Coupling refers to the degree of direct knowledge that one element has of another. Low coupling is generally desirable as it makes systems more maintainable and flexible."
        },
        {
          "id": "arch-1-9",
          "question": "What is cohesion in software design?",
          "options": [
            "How well elements within a module work together",
            "How modules are connected to each other",
            "The performance of the software",
            "The security of the software"
          ],
          "correctAnswer": 0,
          "explanation": "Cohesion refers to how closely related and focused the responsibilities of a single module are. High cohesion is desirable as it makes code more understandable and maintainable."
        },
        {
          "id": "arch-1-10",
          "question": "What is the Strategy Pattern?",
          "options": [
            "A pattern for planning software development",
            "A pattern that defines a family of algorithms and makes them interchangeable",
            "A pattern for optimizing performance",
            "A pattern for handling user strategies"
          ],
          "correctAnswer": 1,
          "explanation": "The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. This lets the algorithm vary independently from clients that use it."
        }
      ]
    },
    "2": {
      "questions": [
        {
          "id": "arch-2-1",
          "question": "What is the primary goal of the Model-View-Controller (MVC) pattern?",
          "options": [
            "To improve application performance",
            "To separate concerns and improve maintainability",
            "To reduce memory usage",
            "To simplify user interface design"
          ],
          "correctAnswer": 1,
          "explanation": "MVC separates an application into three interconnected components: Model (data), View (presentation), and Controller (logic). This separation of concerns improves maintainability, testability, and code organization."
        },
        {
          "id": "arch-2-2",
          "question": "What is the Adapter Pattern?",
          "options": [
            "A pattern for adapting to user preferences",
            "A pattern that allows incompatible interfaces to work together",
            "A pattern for optimizing performance",
            "A pattern for handling multiple inheritance"
          ],
          "correctAnswer": 1,
          "explanation": "The Adapter Pattern allows objects with incompatible interfaces to collaborate by providing a wrapper that translates one interface to another."
        },
        {
          "id": "arch-2-3",
          "question": "What is the Command Pattern?",
          "options": [
            "A pattern for executing system commands",
            "A pattern that encapsulates a request as an object",
            "A pattern for command line interfaces",
            "A pattern for user commands"
          ],
          "correctAnswer": 1,
          "explanation": "The Command Pattern encapsulates a request as an object, allowing you to parameterize clients with different requests, queue operations, and support undo functionality."
        },
        {
          "id": "arch-2-4",
          "question": "What is the Decorator Pattern?",
          "options": [
            "A pattern for UI decoration",
            "A pattern that adds new functionality to objects dynamically",
            "A pattern for code formatting",
            "A pattern for visual design"
          ],
          "correctAnswer": 1,
          "explanation": "The Decorator Pattern allows behavior to be added to objects dynamically without altering their structure, providing a flexible alternative to subclassing."
        },
        {
          "id": "arch-2-5",
          "question": "What is the Repository Pattern?",
          "options": [
            "A pattern for organizing code repositories",
            "A pattern that encapsulates data access logic",
            "A pattern for version control",
            "A pattern for storing user preferences"
          ],
          "correctAnswer": 1,
          "explanation": "The Repository Pattern encapsulates the logic needed to access data sources, centralizing common data access functionality and providing better maintainability and testing."
        },
        {
          "id": "arch-2-6",
          "question": "What is the Facade Pattern?",
          "options": [
            "A pattern for building facades",
            "A pattern that provides a simplified interface to a complex subsystem",
            "A pattern for user interfaces",
            "A pattern for system architecture"
          ],
          "correctAnswer": 1,
          "explanation": "The Facade Pattern provides a simplified interface to a complex subsystem, making it easier to use and reducing dependencies on the internal workings of the subsystem."
        },
        {
          "id": "arch-2-7",
          "question": "What is the Builder Pattern?",
          "options": [
            "A pattern for building software",
            "A pattern for constructing complex objects step by step",
            "A pattern for construction projects",
            "A pattern for building user interfaces"
          ],
          "correctAnswer": 1,
          "explanation": "The Builder Pattern constructs complex objects step by step, allowing you to create different types and representations of an object using the same construction code."
        },
        {
          "id": "arch-2-8",
          "question": "What is the Proxy Pattern?",
          "options": [
            "A pattern for network proxies",
            "A pattern that provides a placeholder or surrogate for another object",
            "A pattern for security proxies",
            "A pattern for database connections"
          ],
          "correctAnswer": 1,
          "explanation": "The Proxy Pattern provides a placeholder or surrogate for another object to control access to it, often used for lazy loading, access control, or caching."
        },
        {
          "id": "arch-2-9",
          "question": "What is the Template Method Pattern?",
          "options": [
            "A pattern for creating templates",
            "A pattern that defines the skeleton of an algorithm in a base class",
            "A pattern for code templates",
            "A pattern for documentation templates"
          ],
          "correctAnswer": 1,
          "explanation": "The Template Method Pattern defines the skeleton of an algorithm in a base class, letting subclasses override specific steps without changing the algorithm's structure."
        },
        {
          "id": "arch-2-10",
          "question": "What is the State Pattern?",
          "options": [
            "A pattern for managing application state",
            "A pattern that allows an object to alter its behavior when its internal state changes",
            "A pattern for state machines",
            "A pattern for managing user sessions"
          ],
          "correctAnswer": 1,
          "explanation": "The State Pattern allows an object to alter its behavior when its internal state changes, making it appear as if the object changed its class."
        }
      ]
    }
  }
}
